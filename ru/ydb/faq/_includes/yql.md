---
sourcePath: ru/ydb/ydb-docs-core/ru/core/faq/_includes/yql.md
---
# YQL

### Общие вопросы {#common}

#### Как выбрать из таблицы строчки по заданному списку ключей? {#explicit-keys}

Выборка строчек таблицы по заданному списку значений первичного ключа (или префикса ключа) таблицы выполняется с помощью оператора `IN`:

```sql
DECLARE $keys AS List<UInt64>;

SELECT * FROM some_table
WHERE Key1 IN $keys;
```

В случае если выборка делается по составному ключу, параметр запроса должен иметь тип списка таплов:

```sql
DECLARE $keys AS List<Tuple<UInt64, String>>;

SELECT * FROM some_table
WHERE (Key1, Key2) IN $keys;
```

Для эффективного выполнения выборки важно, чтобы типы значений в параметрах совпадали с типами ключевых колонок в таблице.

#### Осуществляется ли поиск по индексу для условий, содержащих оператор LIKE? {#like-index}

Оператор `LIKE` может быть использован для поиска по индексу таблицы только в случае, если он задает префикс строки:

```sql
SELECT * FROM string_key_table
WHERE Key LIKE "some_prefix%";
```

#### Почему в результате запроса выводится только 1000 строк? {#result-rows-limit}

1000 строк — ограничение на размер одного результата для YQL запроса. В случае если результат запроса был обрезан, он будет помечен флагом `Truncated`. Чтобы получить большее количество строк из таблицы, можно воспользоваться [постраничным выводом](../../best_practices/paging.md) или операцией `ReadTable`.

#### Как обновить только те значения, ключей которых нет в таблице? {#update-non-existent}

Можно использовать операцию `LEFT JOIN`, чтобы пометить отсутствующие в таблице ключи, после чего обновить их значения:

```sql
DECLARE $values AS List<Struct<Key: UInt64, Value: String>>;

UPSERT INTO kv_table
SELECT v.Key AS Key, v.Value AS Value
FROM AS_TABLE($values) AS v
LEFT JOIN kv_table AS t
ON v.Key = t.Key
WHERE t.Key IS NULL;
```

### Операции Join {#joins}

#### Есть ли особенности в работе операции Join? {#join-operations}

Операция `Join` в {{ ydb-short-name }} выполняется одним из двух способов:

* Common Join;
* Index Lookup Join.

#### Common Join {#common-join}

Содержимое обеих таблиц (левая и правая части `Join`) отправляется на выполняющий запрос узел, где операция выполняется над данными целиком. Это универсальный способ выполнения операции `Join`, который применяется в случае, когда более оптимальные способы неприменимы. Для больших таблиц такой способ или работает медленно, или в общем случае не работает из-за превышения лимитов на пересылку данных.

#### Index lookup Join {#index-lookup-join}

Для строчек из левой части операции `Join` осуществляется поиск (lookup) соответствующих значений в правой части. Данный способ применяется, когда правая часть является таблицей и ключ операции `Join` является префиксом ее первичного ключа или ключа вторичного индекса. При использовании данного способа из правой таблицы делаются ограниченные выборки, вместо полного чтения, что позволяет использовать его при работе с большими таблицами.

{% note info %}

Для большинства OLTP запросов рекомендуется использовать Index Lookup Join с небольшим размером левой части. Такие операции читают мало данных и могут быть выполнены эффективно.

{% endnote %}

#### Как сделать Join с данными из параметров запроса? {#constant-table-join}

Данные из параметров запроса можно использовать как константную таблицу. Для этого нужно использовать модификатор `AS_TABLE` с параметром, имеющим тип списка структур:

```sql
DECLARE $data AS List<Struct<Key1: UInt64, Key2: String>>;

SELECT * FROM AS_TABLE($data) AS d
INNER JOIN some_table AS t
ON t.Key1 = d.Key1 AND t.Key2 = d.Key2;
```

Явного ограничения на количество записей в константной таблице нет, но нужно иметь в виду стандартное ограничение на общий размер параметров запроса (50 МБ).

#### Как лучше реализовать запрос вида (key1, key2) IN ((v1, v2), (v3, v4), ...)? {#key-pairs-in}

Это лучше записывать через JOIN с константной таблицей:

```sql
$keys = AsList(
    AsStruct(1 AS Key1, "One" AS Key2),
    AsStruct(2 AS Key1, "Three" AS Key2),
    AsStruct(4 AS Key1, "One" AS Key2)
);

SELECT t.* FROM AS_TABLE($keys) AS k
INNER JOIN table1 AS t
ON t.Key1 = k.Key1 AND t.Key2 = k.Key2;
```

### Транзакции {#transactions}

#### Насколько эффективно выполнение нескольких запросов в транзакции? {#transaction-queries}

При последовательном выполнении нескольких запросов, суммарный latency для транзакции может быть больше, чем при выполнении тех же операций в рамках одного запроса. В первую очередь это обусловлено дополнительными сетевыми задержками на выполнение каждого из запросов. Поэтому в случае, когда для транзакции не требуется интерактивность, рекомендуется формулировать все операции в одном YQL запросе.

#### Является ли отдельный запрос атомарным? {#atomic-query}

В общем случае YQL-запросы могут выполняться в несколько последовательных фаз. Например, запрос с операцией Join может быть выполнен в две фазы, читающие данные левой и правой таблицы соответственно. Этот аспект является важным при выполнении запроса в транзакции с низким уровнем изоляции (`online_read_only`), так как в этом случае данные между фазами выполнения могут быть изменены другими транзакциями.

### Правильное использование ключей в выборке {#keys-use}

При использовании первичного и вторичного индекс необходимо правильно указывать типы аргументов в запросах. Рассмотрим следующим пример. В

Создадим таблицу и добавим в нее данные:
```sql
CREATE TABLE my_table (
    k1 Uint32,
    k2 Uint64,
    desc Utf8,
    index my_tbl_ind global on(desc),
    PRIMARY KEY (k1,k2)
);
commit;
insert into my_table (k1,k2,desc)
values
(1u,1ul,'desc 11'u),
(2u,2ul,'desc 22'u),
(3u,3ul,'desc 33'u),
(4u,4ul,'desc 44'u),
(5u,5ul,'desc 55'u);
commit;
```

Теперь сформируем запросы по первичному ключу:
```sql
-- DECLARE в данном запросе хотя и лишний - но Вы будете использовать его для передачи параметров при работе с YDB SDK
DECLARE $keys AS List<Tuple<UInt32, UInt32>>;

    -- напомним что [] обозначают литерал List, а () обозначают литерал для Tuple
-- 1u - литерал для Uint32
-- 1ul - литерал для Uint64
-- присваивание для $keys содержит строго типы, определенные в табилце (Uint32 и Uint64)    
$keys=[(1u,1ul),(2u,2ul)];
    
    
-- Запрос1
-- такой запрос формирует тип просмотра MultiLookup и затрагивает ровно 2 строки
SELECT * FROM my_table WHERE (k1, k2) IN $keys;

-- Запрос2
-- такой запрос формирует тип просмотра FullScan и перебирает все 5 строк
-- в отличие от Запрос1 используется Tupple вместо List
SELECT * FROM my_table WHERE (k1, k2) IN ((1u,1ul),(2u,2ul));

-- Запрос3
-- обратите внимание что хотя Запрос3 очень похож на -- Запрос1 - но тем не менее здесь тип аргументов четко не указан - что привело к полному перебору строк - FullScan
SELECT * FROM my_table WHERE (k1, k2) IN [(1,1),(2,2)];

-- Запрос4 - по вторичному индексу
-- запрос затрагивает ровно 2 строки, указан hint view на вторичный индекс
SELECT * FROM my_table view my_tbl_ind  WHERE desc IN ['desc 11'u,'desc 22'u];
-- !!!! Обратите внимание - если не указать литерал u - Utf8 - то произойдет полный перебор всех строк таблицы
```

{% note info %}

**Запомните важное правило!**

Для выборки по ключу крайне важно правильно указывать тип аргументов при выборке. Неверное указание типов приведет к полному перебору таблицы.

{% endnote %}

При использвании вторичного ключа, like с префиксом осуществляет полный перебор таблицы.

```
-- Запрос4
-- FullScan
SELECT * FROM my_table view my_tbl_ind  WHERE desc like 'desc 1%'u

```
